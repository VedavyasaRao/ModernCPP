# Modern C++ #
*Discusses some of the regular and C++ 11 and 14 features*
## TOC ##
|||||
|-|-|-|-|
|[New Language Features➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#new-language-features)|[type traits➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#type-traits)|[Literals and Strings➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#literals-and-strings)|[regular expressions➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#regular-expressions) |
|[localization➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#localization)     | [I/O Streams➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#io-streams)| [Diagnostics➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#diagnostics)|[Containers➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#containers)|
|[iterators➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#iterators)|[Algorithms➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#algorithms)|[General Utilities➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#general-utilities)|[smart pointer➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#smart-pointer-1)
|[chrono library➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#chrono-library)|[Concurrency:stdLib➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#concurrencystdlib)|[Concurrency:win32➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#concurrencywin32)|[Numerical Library➹](https://github.com/VedavyasaRao/ModernCPP?tab=readme-ov-file#numerical-library)|

## New Language Features ##
The following discusses some of the new features introduced in C++11 and 14.
### auto
The auto keyword is remnant of C that was used to declare local variable in a function. In C++ it has a different meaning and is used to assign a data type based on initialized value.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#auto).
### decltype
decltype is reverse of auto where a data type can be deduced from a variable or an expression. decltype can also be used specify return types in template functions.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#decltype).
### declval
It's a template function for type T.It returns an rvalue reference to type T without referring to any object, making it possible to use member functions in the operand of the decltype specifier without the need to go through constructors. T may be an incomplete type.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#declval).
### long long
The size of long is not consistent across platforms. In linux,  it's 64 bits and in Windows it's 32 bits.The new data type long long is a 64 bits across all the platforms.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/numerical-library.html#long_long).
### nullptr_t
nullptr_t data type is introduced specifically to prevent misuse of NULL in place of null pointers. nullptr is the only instance of this type and can be used in place of a null pointer.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/smartpointers.html#nullptr).
### char16_t and char32_t
char16_t  and char32_t  were introduced to provide uniformity among other things. The size of char16_t data type is fixed at 16 bits and the size of char32_t data type is fixed at 32 bits across all the platforms. char16_t is used for UTF-16 encoding and   char32_t is used for UTF-32 encoding.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/strings-and-literals.html#char16_t).
### constexpr
The keyword constexpr means constant expression. Like const, it can be applied to variable. Also, unlike const, constexpr can also be applied to functions and class constructors. constexpr indicates variable value, or return value, which is constant and, where possible, is computed at compile time.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/constexpr.html).
### =default
=default
In  C++ 11, a class can define following special member functions.
- default constructor
- copy constructor
- copy assignment operator
- destructor
- move constructor
- move assignment operator 
If it's missing, the compiler conditionally generates some of these functions.
Sometimes it's desirable to explicitly generate these functions, when it's not generated by the compiler  using keyword =default. 
More details can be found [here➹](https://modcpp11.blogspot.com/2024/05/defaut-and-delete.html#=default).
### =delete
It's also possible to suppress conditional generation of these functions by using keyword =delete.  
More details can be found [here➹](https://modcpp11.blogspot.com/2024/05/defaut-and-delete.html#=delete).
### initializer_list
The C++11 standard library introduced a new template based type initializer_list <T> to handle variable-length {}-lists. initializer_list is used to aid uniform initialization. It's automatically created when braces {} are used to initialize.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/list-initialization.html#initializer_list).
### list initialization
list initialization enables uniform way of initializing arithmetic types such as int, double etc or structs, classes using a pair of braces {}.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/list-initialization.html#list_initialization).
### rvalue reference
When using containers such as lists, vectors, maps, a lot of temporary objects are created and destroyed during the life time of an application. 
To overcome this, rvalue reference and move semantics are introduced.  An rvalue reference behaves just like an lvalue reference except that it can bind to a temporary value.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/move-semantics.html#rvalue).
### move
move semantics takes advantage of  the new rvalue reference to optimize temporary object creation and its reuse.   
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/move-semantics.html#move).
### perfect forwarding
The rvalue semantics enable passing the arguments without ambiguity  to the handler function in the factory method.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/move-semantics.html#Perfect).
### Universal reference
Before C++11, universal reference was used to bind to both rvalue and lvalue. An universal reference is formed by making const reference of some type as shown below.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/move-semantics.html#universal).
### namespace
In large projects, multiple classes can share same name, which can lead to compilation errors and confusion. namespace can be used to modularise them in separately to avoid overlapping. 
More details can be found [here➹](https://modcpp11.blogspot.com/2024/07/namespaces-and-using.html#namespace).
### using
typedefs are commonly used provide an alias to a type. However it has some limitations when used in templates. In C++ 11, using keyword is introduced to overcome these limitations also extend its functionality.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/07/namespaces-and-using.html#using).
### noexcept
noexcept specifier determines whether a function could throw exceptions.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#noexcept).
### override
n a multi class hierarchy, virtual functions enable overriding base class functionality by derived classes. However sometimes it can be confusing and often mistakes can happen in a large project if the signatures don't match in the derived classes. The suffix override is designed to overcome this. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#override).
### final
Sometimes it's desirable to prevent overriding a virtual function or derivation from a class itself. The suffix final is designed to handle it.
final keyword indicates compiler that a virtual function of a base class cannot be overridden. in derived classes. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#final).
### range for loop
*for* loops are versatile can be used in various scenarios. *range based for* loop are designed to work with containers so that their elements for a given range can be iterated directly either by value or a by reference.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#range).
### static_assert
Macros such as assert() can be used in debug builds to check for errors during runtime to break when an error condition becomes true.
More details can be found [here➹](https://modcpp11.blogspot.com/p/new-language-support.html#static_assert).
### variadic template
With the variadic templates feature, it's possible to define template based class or function that can have any number (including zero) of parameters. 
To accomplish this, a new kind of parameter called parameter pack is introduced that can singly represent a list of zero or more parameters in the templates definition. A template class or function with at least one parameter pack is called a variadic template.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/09/variadic-templates.html).
## type traits ##
type_traits were introduced in C++11, basically defines templates for compile-time constants that give information about the properties of their type arguments, or produce transformed types. The classes and templates in type_traits are used to support type inference, classification, and transformation at compile time.
### Utility classes
type traits classes internally uses a number of utility classes  such as integral_constant in its implementation. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/type-traits.html#Utility).
### Unary type traits
Unary Type Traits describe a property of a single type. Most Unary Type Traits return true or false and are derived from true_type or false_type. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/type-traits.html#Unary).
### Binary Type Traits
Binary Type Traits provide information about a relationship between two types. Every Binary Type Trait return  true_type  or false_type. based on the presence or absence of a specific relationship between the two argument types.
More details can be found [here➹](https://modcpp11.blogspot.com/p/type-traits.html#Binary).
### Transformation Type Traits
Transformation Type Traits modify a type. Every Transformation Type Trait possesses a nested typedef named type that represents the result of the modification. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/type-traits.html#Transformation).
### Memory Allocation
Allocate uninitialized memory of POD type.
More details can be found [here➹](https://modcpp11.blogspot.com/p/type-traits.html#Memory).
## Literals and Strings ##
strings and literals are essential part of any programming language. The following describes various facilities and classes available to handle strings and literals.
### char_traits
char_traits classes define common behavior such as comparison, assignment, copy etc. and also other aspects such as eof  type, offset type position type etc.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/11/chartraits.html).
### char16_t and char32_t
char16_t  and char32_t  were introduced to provide uniformity among other things. The size of char16_t data type is fixed at 16 bits and the size of char32_t data type is fixed at 32 bits across all the platforms. char16_t is used for UTF-16 encoding and   char32_t is used for UTF-32 encoding.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/strings-and-literals.html#char16_t).
### Unicode String Literals
string literals prefixed with u8 are encoded as UTF-8. Similarly, prefix for UTF-32 encoded strings is U. char_32_t is used for encoding UTF-32 strings. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/strings-and-literals.html#Unicode).
### raw string
Assigning a free flowing text to a string variable has been a challenge especially if it contains " character embedded in it.The raw string feature enables declaring strings containing special characters such as newline, tab etc as is without escaping.
More details can be found [here➹](https://modcpp11.blogspot.com/p/strings-and-literals.html#raw).
### user defined literals
In  C++, arithmetic types such as long, float can be represented with suffix as 1L,1.2f etc. C++11 extends this to represent standard library and user defined types using user defined literals.
More details can be found [here➹](https://modcpp11.blogspot.com/p/strings-and-literals.html#user).
### basic_string
CRT provides plethora of functions to handle strings. There are different functions for getting length, append, copy, find etc. 
std::basic_string class attempts to objectify strings so that it's easier to use.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/string.html).
## regular expressions ##
Regular expressions are indispensable when looking for a specific information.
They are highly versatile to filter out information or for validating inputs without needing to write lots of code.  
### Validation
Regular expressions can be used to validate an input.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Validation).
### Extraction
Regular expressions can be used to extract information from the input strings.   
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Extraction).
### Dot character
Patterns can use . to map any character except some control characters. Note that it has no effect in a character class construct and maps to decimal point.   
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Dot).
### Character class
The basic ingredient of the regular expression grammar is a character class. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Character).
### Shorthands
To reduce clutter, shorthands to character classes are provided. These can be freely used in another character class or even in pattern.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Predefined).
### Escaping
Some times a meta character needs to be escaped in a pattern or a character class. Escaping is done by placing \  in front of the meta character. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Escaping).
### Anchors and boundary markers
Anchors and  boundary markers marks special locations such as beginning or ending of the lines, word boundaries etc. These can be used only in the pattern and not in character classes.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Anchors).
### Quantifiers
Quantifiers determine  repetitiveness of a token in the pattern. Quantifiers applies to any token in the pattern only. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Quantifiers).
### Greedy, Lazy and Possessive Quantifiers
Produces different results for the same patteren with different Quantifiers.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Greedy).
### Capture groups
The capture groups are one of the key aspects of the regular expression.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Capture).
### Non capturing groups
Non capturing groups are used for efficiency and optimization. As the name indicates, contents of non capturing groups are discarded.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Capture2).
### References
aptured groups in a pattern are internally labeled as \1, \2 , \3 etc.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#References).
### Unicode support
The behavior of the regular expression engine can be changed by setting flags in the pattern.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Unicode).
### Branch Reset Groups
Consider a pattern (1a)|(2a)|(1b)\1. This defines three capture groups. For the input 1a1a, it is expected to match, however it does not.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Branch).
### LookAround
There are 4 types look around, positive/negative look ahead/behind. Collectively they are called lookaround, are zero-length assertions just like the start and end of line, or start and end of word anchors. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#LookAround).
### LookBehind with \K
Due to certain restriction in matching expression of positive lookbehind i.e., <=expression,  as an alternative to positive lookbehind, \K switch can be used. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#LookBehind).
### Atomic Grouping
An atomic group is a group that, when the regex engine exits from it, automatically throws away all backtracking positions remembered by any tokens inside the group. 
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Atomic).
### If-Then-Else Conditionals
If-Then-Else is a special construct allows creation of conditional regular expressions.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#If).
### Recursion
Suppose the task is to find out if random number of open and close braces such as () or {} match, regular expression recursion comes to the rescue.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Recursion).
### Subroutines
Subroutines are applied to the capture groups. These are very similar to regular expression recursion. Instead of matching the entire regular expression again, a subroutine call only matches the regular expression inside a capturing group. A subroutine call can be made to any capturing group from anywhere in the pattern. A call made to same capturing group leads to recursion.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Subroutines).
### Using Regular expressions in C++
It's possible to replace  captured groups or entire match. Regular expressions is a part of in C++ 11 standard library,  however it does not support many features discussed here. An alternate would be to use boost libraries which seems compatible with feature rich  perl.
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/regular-expression-quick-tour-with_6.html#Using).
## localization ##
Each country has one or more native speaking languages and writing systems or a scripts, numbering symbols, number grouping symbol, decimal point symbol, currency symbols, date format etc. 
The *locale* and *facet* classes provide the support for all these aspects so that it can be integrated into the daily lives of the people, government and businesses etc.  
### Character Set
A Character Set is a set of characters identifying a particular writing system of a particular region.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Character_Set).
### Encoding
Character encoding is the process of assigning numbers to the characters of the character set, allowing them to be stored, transmitted, and transformed using digital computers so that they can be reinterpreted back correctly. 
More details can be found [here➹](https://modcpp11.blogspot.com/2025/01/encoding.html).
### codepages
A code page is basically a coded character set. The term code page initially referred to the page number of IBM standard character set manual containing character mapping for plethora of character sets. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#codepages).
### Localization
Internationalization is the process of designing and developing software or applications to be accessible and adaptable to different languages, cultures, and regions. Localization is the process of adapting software or applications to meet the language, cultural, and other requirements of a specific target market or locale. 
While internationalization creates a framework that supports multiple languages and regions, localization involves customizing the software or application for a specific target market or region.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Localization).
### Locales
A locale is a collection of information pertaining to a culture, region, and language. Locales are physically stored in external files in POSIX environments. In Windows, they are located in the registry.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Locales).
### Locales in C
In C, locales can be set using setlocale() api.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Locales_C).
### locale class
In C++, a locales are represented by a locale object, which  is a collection of indexed facets. It also contains a basic_regex object.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/01/locale.html).
### Facets
facets are defined for each category.  It's possible to override default behavior of a fact.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Facets).
### Character classification and conversion
CRT provides set of functions to classify characters and changes their cases to  upper or lower. Standard library also provides template based functions to provide the same facility.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/character-classification-and-conversion.html).
### Unicode Conversion Facets
he following are Codecvt based facets to convert Unicode based formats with each other. For example, conversion from  UTF-8 to UCS-2, UTF-16 and UTF-32. Also reverse.
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#Unicode_Conversion).
### String and stream conversions
Performs conversions between wide strings and byte strings (on either direction) using a conversion object of type 
More details can be found [here➹](https://modcpp11.blogspot.com/p/localization.html#stream_conversions).
## I/O Streams ##
The CRT provides  printf() variants to emit formatted output of data such as integers, boolean, strings etc. on different targets such as console, character buffers, files. 
Similarly, CRT also provides  scanf() variants to extract input from console, character buffers, files for data such as integers, boolean, strings etc
### Class Structure
The following depicts the class structure. Note that classes that start with the letter w are defined for whcar_t and other classes are defined for char. char16_t and char32_t are not supported. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#Structure).
### Class Organization
The classes can be grouped into following categories - Primitive base, Intermediate base , disk based  streams and String based streams.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/01/class-organization.html).
### Primitive Base classes
The following describes each of the bases classes in detail. It also includes console I/O stream objects.
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#Primitive).
### IO Stream extraction and insertion operators and Manipulators
istreams defines extraction operators that are basically overloaded operator >>() functions to extract values from the inputs. Similarly, ostreams defines insertion operators that are basically overloaded operator<<() functions to insert values into the output.
Manipulators are helper functions that prepare the input/output streams before using operator << or operator >>.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/input-output-manipulators.html).
### Disk based Streams
These provides stream classes  that can be used Input only, Output only or Both with files.
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#Disk).
### String based streams
These provides stream classes  that can be used Input only, Output only or Both with string.
Classes that does input only are derived from basic_istream. Similarly classes that does output only are derived from basic_ostream. Classes that do both input and output are derived from basic_iostream class.
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#String).
### Stream iterators
istream_iterator and ostream_iterator can be used for typed input and  output. They are faster as they skip construction of sentry objects.
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#iterators).
### Streambuf iterators
streambuf defines input iterator and output iterator for untyped input and output.
istreambuf_iterator and ostreambuf_iterator can be used instead of raw i/o apis.
More details can be found [here➹](https://modcpp11.blogspot.com/p/io-and-locales.html#Streambuf_iterators).
## Diagnostics ##
The CRT provides  printf() variants to emit formatted output of data such as integers, boolean, strings etc. on different targets such as console, character buffers, files. 
Similarly, CRT also provides  scanf() variants to extract input from console, character buffers, files for data such as integers, boolean, strings etc
### exception class
n C++ 11, a new family of classes were introduced to handle exceptions with exception class as its root. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/diagnostics.html#exception).
### Standard Library Exception hierarchy
The following shows the hierarchy of exceptions. Some of these are thrown by the standard library. It can be grouped into three categories. User applications can also throw them.
More details can be found [here➹](https://modcpp11.blogspot.com/p/diagnostics.html#Standard).
### Standard Library Exception Categories
This discusses various standard library exceptions with examples.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/standard-library-exceptions.html).
### Advanced Exception Handling
The following discusses how to handle an exception, nested exceptions, uncaught and unexpected exceptions, termination. Also setting exception and termination handlers.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/exceptionptr.html).
### Handling Exception Failures
When an exception is unhandled, it leads to termination of the application. The following discusses setting up custom handlers that's called before before termination.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/handling-exception-failures.html).
### System Errors
System error numbers are different in different platforms. e.g., file system errors.  In C++11,  a new exception class system_error along with helper classes - error_category,  error_code, error_condition 
were introduced to the diagnostic infrastructure to bring uniformity and develop cross platform applications.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/system-errors.html).
### Predefined System error enumerations
The standard library provides predefined enumeration classes to define error conditions for these categories: generic_category, iostream_category and future_categoty.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/predefined-system-error-enumarations.html).
## Containers ##
STL provides a host of template based containers serving as arrays and lookups to store and retrieve any data type.
### sequence containers
These containers  store data sequentially using different mechanisms.
More details can be found [here➹](https://modcpp11.blogspot.com/p/algorithms_22.html#sequence).
### container adapters
Container adapters provide specialized functionality and are based on a sequence container.
More details can be found [here➹](https://modcpp11.blogspot.com/p/algorithms_22.html#adapters).
### associative containers
These are basically lookup tables that store key value pairs. They can be classified into two categories - ordered and unordered.  The ordered category containers are implemented using balanced binary trees whereas the the unordered category containers are implemented using hash tables. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/algorithms_22.html#associative).
### associative containers
These are basically lookup tables that store key value pairs. They can be classified into two categories - ordered and unordered.  The ordered category containers are implemented using balanced binary trees whereas the the unordered category containers are implemented using hash tables. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/algorithms_22.html#associative).
### emplacement functions
STL containers such as vector, list, map to provide pushxxx and insert  functions to add new elements.
Most of these functions endup creating a temporary object of the type T of the container.
In C++ 11,  pushxxx and insert  function variants that would accept a rvalue reference were added. Also a new emplace functions were that would accept added to directly construct the object of type T in the container. Perfect forwarding is used to pass parameters for its constructor.
More details can be found [here](https://modcpp11.blogspot.com/2024/05/emplacement-functions.html).
## iterators ##
STL provides a host of template based iterators that act as glue between containers and algorithms.
### Operation
An iterator basically wraps a range of elements from a STL container or even an array. It's analogues to a smartpointer. 
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#Operation).
### overloaded operators
The table below describes each of the overloaded operator in detail.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#overloaded).
### Iterator Classification
Iterators can be broadly classified as below based on their behavior.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#Classification).
### iterator traits
As noted earlier, an iterator acts as glue between containers and algorithms. An algorithm need not know all about the containers except for a few specific details such as type of iterator, or the value_ type.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#iterator_traits).
### iterator apis
terator apis generate iterators and enable manipulating iterators to change positions. As shown below, two categories of iterators are supported - forward and reverse. Forward iterators traverse from the first element to the last element. Reverse iterators traverse from the last element to the first element.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#iterator_apis).
### predefined iterator adaptors 
Iterator adaptors are a separate type of iterators with special behavior. They simplify the work with containers and are very useful in standard algorithms.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#iterator_adaptors).
### predefined stream iterators
Following stream iterators are predefined.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#stream_iterators).
### uninitialized_memory
Following iterators are defined.
More details can be found [here➹](https://modcpp11.blogspot.com/p/iterators.html#uninitialized_memory).
## Algorithms
The standard library template based algorithms to process containers using iterators for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements.
### Complexity Analysis
Asymptotic Notation is used to describe the represent time complexity of an algorithm where it represents time taken to execute the algorithm for a given input, n. 
More details can be found [here➹](https://modcpp11.blogspot.com/2024/11/complexity-analysis.html).
### Binary Search
Binary search algorithms  operate on various types of containers such as sequence, associative and unordered that are sorted to perform actions such as finding upper, lower, equal bounds for a value or its existence.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-binary-search.html).
### Heap
Heap Algorithms  operate on various types of containers such as sequence, associative and unordered to organize the elements of a range that allows for fast retrieval of the element with the highest 
value at any moment (with pop_heap), even repeatedly, while allowing for fast insertion of new elements  (with push_heap).  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-heap.html).
### Lexicographical
Lexicographical algorithms  operate on various types of containers such as sequence, associative and unordered to perform lexicographical actions such as comparing elements, generate sequences etc.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-numerics.html).
### Merge
Merge algorithms  operate on various types of containers such as sequence, associative and unordered to perform actions such as merging sorted sequences, set union, intersection and differences.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-search-and-merge.html).
### Min/Max
Min/Max Algorithms  are template based functions that operate on various types of containers such as sequence, associative and unordered to perform actions such as finding the smallest and the largest element.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-minmax.html).
### Modifying
Modifying Algorithms  operate transparently on containers such as lists, vectors, maps, sets, arrays etc.  using a pair of iterators, These are collectively known as sequences. They perform actions such as  replace, remove, copy etc.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/algorithms-modifying.html).
### Non modifying
Non Modifying Algorithms  operate transparently on containers such as lists, vectors, maps, sets, arrays etc.  using a pair of iterators, These are collectively known as sequences. They perform actions such as search, find, count etc.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/11/algorithmsnon-modifying.html).
### Numerical
Numerical algorithms  operate on various types of containers such as sequence, associative and unordered to perform operations on the elements of a range to return a value or a sequence.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-numerical.html).
### Partitions
Partitions are commonly used for searching and sorting. Partitioning algorithms  operate on various types of containers such as sequence, associative and unordered to perform actions such as partition, sort and more.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-partitions_18.html).
### Sort
Sorting Algorithms  operate on various types of containers such as sequence, associative and unordered to perform actions such as sorting.  
More details can be found [here➹](https://modcpp11.blogspot.com/2023/12/algorithms-partitions.html).
### uninitialized memory
uninitialized memory algorithms enable populating objects in uninitialized memory. They construct the objects in-place, This allows to obtain fully constructed copies of the elements into a range of uninitialized memory, such as a memory block obtained by a call to malloc.
More details can be found [here➹](https://modcpp11.blogspot.com/2024/10/unintialized-memory.html).
## General Utilities
Function Objects or Functors are widely used in std library and serve in various modes such as passing ref objects, wrapping up function objects, accessing member functions etc. 
### Functors
A functor is an object or structure that can be called like a function by overloading the function call operator () .  Functors also wrap a state during construction which can be used in function calls.
More details can be found [here➹](https://modcpp11.blogspot.com/p/general-utilities.html#Functors).
### lambda expression
A functor or function objects is an object or structure that can be called like a function by overloading the function call  
More details can be found [here➹](https://modcpp11.blogspot.com/2024/12/lambda-expression.html).
### predefined function objects
Predefined function objects are defined in the std. library to perform bitwise, relational, logical and arithmetic operations.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/general-utilities.html#Predefined).
### function and class member pointers
function pointers are pointers to functions that can be defined as variables. function pointer can be defined for "C" type free functions as shown below.
More details can be found [here➹](https://modcpp11.blogspot.com/p/general-utilities.html#functionptr).
### reference_wrapper
reference_wrapper is a class template that creates a wrapper around a reference to object or reference to function of type T. Instances of reference_wrapper are objects but they are implicitly convertible to T&, so that they can be used as arguments with the functions that take the underlying type by reference.  
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/referencewrapper.html).
### ref and cref
Function templates ref and cref are helper functions that generate an object of type reference_wrapper, using template argument deduction to determine the template argument of the result.  
More details about ref can be found [here➹](https://modcpp11.blogspot.com/2025/02/referencewrapper.html#ref).
More details about cref can be found [here➹](https://modcpp11.blogspot.com/2025/02/referencewrapper.html#cref).
### function
A function class can wrap any kind of callable element (such as functions and function objects) into a copyable object, and whose type depends solely on its call signature (and not on the callable element type itself).  
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/function.html).
### placeholder namespace
This namespace defines an unspecified number of objects: _1, _2, _3,..._N, where _N is implementation specific upper limit. 
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/function.html#placeholder).
### placeholder namespace
This namespace defines an unspecified number of objects: _1, _2, _3,..._N, where _N is implementation specific upper limit. 
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/function.html#is_placeholder).
### mem_fn
This function converts member function to a functor whose functional call invokes the member function pointed by pm.  
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/function.html#mem_fn).
### bind
bind function returns a function object based on fn, but with its arguments bound to args. The syntax is as shown below.  
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/function.html#bind).
### smart pointer
CRT does not have garbage collector support therefore  dangling pointers, leaked resources causes instability in applications. Smartpointers are  used to get around this issue. A Smartpointer is basically a RAII (Resource Acquisition Is Initialization) object that wraps a pointer to an object or an array. New classes such as *unique_ptr* for sole ownership, *shared_ptr* for shared ownership and *weak_ptr* for non ownership references.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/general-utilities.html).
### allocator
Allocators are classes that define memory models to be used by some parts of the Standard Library, and most specifically, by STL containers.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/allocator.html).
### allocator_traits
This template supplies a uniform interface for allocator types.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/allocatortraits.html).
## smart pointer ##
Internally C/C+++ runtime does not have garbage collector support therefore  dangling pointers, leaked resources causes instability in applications. Smartpointers are  used to get around this issue. 
### allocator
Allocators are classes that define memory models to be used by some parts of the Standard Library, and most specifically, by STL containers.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/allocator.html).
### nullptr_t
nullptr_t data type is introduced specifically to prevent misuse of NULL in place of null pointers. nullptr is the only instance of this type and can be used in place of a null pointer.  
More details can be found [here➹](https://modcpp11.blogspot.com/p/smartpointers.html#nullptr).
### smartpointer
A Smartpointer is basically a RAII (Resource Acquisition Is Initialization) object that wraps a pointer to an object or an array. When the smartpointer object is destroyed, the underlying memory of the pointer is released. A smartpointer uses dereferencing operators such as [], * and -> to access the object or its members the pointer is inferring.
More details can be found [here➹](https://modcpp11.blogspot.com/p/smartpointers.html#smartpointer).
### default_delete
default_delete is a functor object. aka deleter  object used by smart pointers to recycle the resources.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/defaultdelete.html).
### unique_ptr
unique_ptr are useful when a resource such as a piece of memory or a file handle needs to be singly managed.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/uniqueptr.html).
### shared_ptr
shared_ptr are useful when a resource such as a piece of memory or a file handle can be collectively shared by multiple owners.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/sharedptr.html).
### weak_ptr
A weak_ptr is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by shared_ptr. It must be converted to shared_ptr in order to access the referenced object.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/03/weakptr.html).
## chrono library ##
Chrono library defines a set of Clocks that can represent a Duration or a specific Time Point. These are used by concurrency object APIs (*sleep_for(duration)* and *sleep_until(time_point)*) to pause processing within a thread.  
### ratio library
standard library defines a new template class *ratio* to define ratios that can be used only during compile time.*ratio* is used in chrono library to represent different time units such as millisecond, hour etc.  
More details can be found [here➹](https://modcpp11.blogspot.com/2025/01/ratio-library.html).
### Terminology
duration means a fixed number of  time units. A clock is a device that has a starting time or epoch time and a resolution or period. time_point is associated with a clock 
More details can be found [here➹](https://modcpp11.blogspot.com/p/chrono-library.html#Terminology).
### duration
duration means a fixed number of  time units. A Time unit could be a second or a millisecond or any user defined such as a day or a month. Examples, 10 milliseconds. 2 days etc.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/duration.html).
### clocks
Chrono library defines three clocks as defined below. The configuration may vary based on platform
More details can be found [here➹](https://modcpp11.blogspot.com/p/chrono-library.html#clocks).
### time_point
time_point is associated with a clock . It represents the duration since epoch time of the clock.
More details can be found [here➹](https://modcpp11.blogspot.com/2025/02/timepoint.html).
### POSIX time functions
POSIX CRT functions are widely used for time calculations. Some of the functions use the data types discussed below. In addition, environment time variable TZ is used for time zone settings.
More details can be found [here➹](https://modcpp11.blogspot.com/p/chrono-library.html#POSIX).
## Concurrency:stdLib ##
Standard library concurrency objects can be broadly classified into five categories.
### Execution Utilities Classes
These classes store the result or exception to be retrieved asynchronously. They include promise, future, shared_future
More details can be found [here➹](https://modcpp11.blogspot.com/p/concurrency.html#Execution_Utilities).
### Execution Classes and functions
These classes can execute code asynchronously. They include async(), thread, this_thread, packaged_task
More details can be found [here➹](https://modcpp11.blogspot.com/p/concurrency.html#Execution_Classes).
### Synchronization Classes and functions
These classes provide synchronization between Execution Classes. They include mutex, timed_mutex, recursive_mutex, recursive_timed_mutex, conditional variable, conditional variable_any, call_once()
More details can be found [here➹](https://modcpp11.blogspot.com/p/concurrency.html#Synchronization_Classes).
### Synchronization Utility Classes
These classes provide wrapper for Synchronization classes. They include lock_guard, unique_lock, shared_lock, lock()
More details can be found [here➹](https://modcpp11.blogspot.com/p/concurrency.html#Synchronization_Utility).
### Lock free programming
The synchronization mechanisms discussed earlier uses operating system provided objects using atomic classes which provide interlocked atomic operations.. They include atomic, atomic_flag
More details can be found [here➹](https://modcpp11.blogspot.com/p/concurrency.html#Lock_free).
## Concurrency:win32 ##
The following discusses concurrency objects that are available in Windows win32 API and from standard library.
### Execution objects
These objects execute code in threads, thread pools APC queues.
More details can be found [https://modcpp11.blogspot.com/2024/11/win32-synchronization-objects.html#Execution).
### Synchronization objects
These objects are used by execution objects to provide synchronizations within a process or across. Some provide specialization for reader-writer and producer - consumer scenarios. They include Critical Section,Mutex,Event,Semaphore,Slim Reader/Writer,Conditional Variable,WaitOnAddress,InitOnce,Interlocked
More details can be found [here➹](https://modcpp11.blogspot.com/2024/11/win32-synchronization-objects.html).
## Numerical Library ##
Standard Library provides classes such as bitset to handle bits, valarray to handle matrix operations. random number generators and distributions.
### long long
The size of long is not consistent across platforms. In linux,  it's 64 bits and in Windows it's 32 bits.
The new data type long long address this by keeping size at 64 bits across all the platforms. 
More details can be found [https://modcpp11.blogspot.com/p/numerical-library.html#long_long).
### long long
The size of long is not consistent across platforms. In linux,  it's 64 bits and in Windows it's 32 bits.
The new data type long long address this by keeping size at 64 bits across all the platforms. 
More details can be found [https://modcpp11.blogspot.com/p/numerical-library.html#long_long).
### numeric limits
Maximum and minimum values of integral types such as int, short, long have been defined in <climits>.
Similarly, Maximum and minimum values for float, double are defined in <cfloat>. However these are defined as macros. For example, INT_MAX, INT_MIN, FLT_MIN,FLT_MAX etc.
More details can be found [https://modcpp11.blogspot.com/2023/10/numeric-limits.html).
### valarray
In C/C++,  fixed size arrays can be allocated on the stack and variable size arrays are allocated on the heap. However this is inflexible and also managing  the array such as adding elements, removing elements or retrieving will require extra code. 
The standard library provides valarray class is similar to a vector but mathematical functions can be applied directly to all the elements. It also allows to get different cross section of the elements in the valarray including  multidimensional using helper classes.
More details can be found [https://modcpp11.blogspot.com/2024/09/valarray.html).

